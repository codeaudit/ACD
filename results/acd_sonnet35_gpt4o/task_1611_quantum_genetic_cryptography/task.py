import random
import math

class TaskFamily:
    @staticmethod
    def get_tasks() -> dict[str, dict]:
        tasks = {
            "1": {
                "key_length": 256,
                "population_size": 100,
                "mutation_rate": 0.01,
                "crossover_rate": 0.7,
                "generations": 50,
                "quantum_inspired_feature": "superposition"
            },
            "2": {
                "key_length": 512,
                "population_size": 200,
                "mutation_rate": 0.005,
                "crossover_rate": 0.8,
                "generations": 100,
                "quantum_inspired_feature": "entanglement"
            }
        }
        return tasks

    @staticmethod
    def get_instructions(t: dict) -> str:
        return f"Design a quantum-inspired genetic algorithm for cryptographic key generation with the following parameters:\n\n" \
               f"1. Key length: {t['key_length']} bits\n" \
               f"2. Population size: {t['population_size']}\n" \
               f"3. Mutation rate: {t['mutation_rate']}\n" \
               f"4. Crossover rate: {t['crossover_rate']}\n" \
               f"5. Number of generations: {t['generations']}\n" \
               f"6. Quantum-inspired feature: {t['quantum_inspired_feature']}\n\n" \
               f"Your response should include the following sections:\n\n" \
               f"1. Algorithm Design (300-350 words):\n" \
               f"   a) Describe the overall structure of your quantum-inspired genetic algorithm.\n" \
               f"   b) Explain how you incorporate the quantum-inspired feature ({t['quantum_inspired_feature']}) into the genetic algorithm.\n" \
               f"   c) Detail the encoding scheme for representing cryptographic keys as quantum-inspired chromosomes.\n" \
               f"   d) Describe the fitness function used to evaluate the quality of generated keys.\n" \
               f"   e) Explain the selection, crossover, and mutation operators, emphasizing their quantum-inspired aspects.\n\n" \
               f"2. Implementation Details (200-250 words):\n" \
               f"   a) Provide pseudocode for the main components of your algorithm.\n" \
               f"   b) Explain how you handle quantum-inspired operations within classical computing constraints.\n" \
               f"   c) Discuss any optimizations or novel techniques you've incorporated to improve efficiency.\n\n" \
               f"3. Security Analysis (200-250 words):\n" \
               f"   a) Analyze the security properties of the keys generated by your algorithm.\n" \
               f"   b) Compare the strength of your quantum-inspired approach to traditional key generation methods.\n" \
               f"   c) Discuss potential vulnerabilities and how they might be addressed.\n" \
               f"   d) Compare your approach with post-quantum cryptography methods.\n\n" \
               f"4. Performance Evaluation (150-200 words):\n" \
               f"   a) Describe metrics for evaluating the performance of your algorithm (e.g., convergence rate, key quality).\n" \
               f"   b) Discuss expected performance characteristics based on the given parameters.\n" \
               f"   c) Suggest how performance might scale with increasing key length or population size.\n\n" \
               f"5. Practical Applications (200-250 words):\n" \
               f"   a) Propose two specific applications for your quantum-inspired genetic cryptographic system.\n" \
               f"   b) Discuss the potential advantages and challenges of implementing your system in these applications.\n" \
               f"   c) Explain how your system might be integrated with existing cryptographic protocols or infrastructure.\n\n" \
               f"6. Ethical Considerations (100-150 words):\n" \
               f"   a) Discuss potential ethical implications of your quantum-inspired genetic cryptographic system.\n" \
               f"   b) Address concerns related to privacy, security, and potential dual-use applications.\n" \
               f"   c) Propose guidelines for responsible development and use of this technology.\n\n" \
               f"7. Future Directions (150-200 words):\n" \
               f"   a) Suggest two potential improvements or extensions to your algorithm.\n" \
               f"   b) Discuss how true quantum computing might influence or enhance your approach in the future.\n" \
               f"   c) Propose a novel research question that arises from your work.\n\n" \
               f"Ensure your response demonstrates a deep understanding of quantum computing principles, genetic algorithms, and cryptography. Use appropriate technical terminology and provide clear explanations for complex concepts. Be innovative in your approach while maintaining scientific plausibility and addressing practical considerations.\n\n" \
               f"Format your response with clear headings for each section. Your total response should be between 1300-1600 words."

    @staticmethod
    def score(t: dict, submission: str) -> float | None:
        from src.eval_helper import eval_with_llm_judge
        instructions = TaskFamily.get_instructions(t)
        criteria = [
            "The response demonstrates a deep understanding of quantum computing principles, genetic algorithms, and cryptography.",
            "The algorithm design effectively incorporates the specified quantum-inspired feature.",
            "The implementation details are clear, logical, and technically sound.",
            "The security analysis is thorough, considers potential vulnerabilities, and compares the approach with post-quantum cryptography methods.",
            "The performance evaluation proposes relevant metrics and discusses scalability.",
            "The practical applications are innovative and well-reasoned.",
            "The ethical considerations section addresses relevant concerns and proposes responsible guidelines.",
            "The future directions suggest meaningful improvements and pose an interesting research question.",
            "The response is well-structured, adheres to the word count, and uses appropriate technical terminology."
        ]
        try:
            return 1.0 if eval_with_llm_judge(instructions, submission, criteria) else 0.0
        except Exception as e:
            print(f"Error in scoring: {e}")
            return 0.0
